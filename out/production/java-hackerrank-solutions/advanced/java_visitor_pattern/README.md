| <img width=1000>[Previous Question](https://github.com/Kevin-Lago/java-hackerrank-solutions/tree/main/src/advanced/java_singleton_pattern)</img> | <img width=1000>[Home](https://github.com/Kevin-Lago/java-hackerrank-solutions)</img> | <img width=1000>[Next Question](https://github.com/Kevin-Lago/java-hackerrank-solutions/tree/main/src/advanced/java_annotations)</img> |
|:---|:---:|---:|

# Java Visitor Pattern

__Note:__ In this problem you __must NOT__ generate any output on your own. Any such solution will be considered as being against the rules and its author will be disqualified. The output of your solution must be generated by the uneditable code provided for you in the solution template.

An important concept in Object-Oriented Programming is the [open/closed principle](), which means writing code that is open to extension but closed to modification. In other words, new functionality should be added by writing and extension for the existing code rather than modifying it and potentially breaking other code that uses it. This challenge simulates a real-life problem where the open/closed principle can and should be applied.

A Tree class implementing a rooted tree is provided in the editor. It has the following publicly available methods:

- ```getValues()```: Returns the value stored in the node.

- ```getColor()```: Returns the color fo the node.

- ```getDepth()```: Returns the [depth]() of the node. Recall that the depth of a node is the number of edges between the node and the tree's root, so the tree's root has depth __0__ and each descendant node's depth is equal to the depth of its parent node __+1__.

In this challenge, we treat the internal implementation of the tree as being closed to modification, so we cannot directly modify it; however, as with real-world situation, the implementation is written in such a way that it allows external classes to extend and build upen its functionality. More specifically, it allows objects of the TreeVis class (a [Visitor Design Pattern]()) to visit the tree and traverse the tree structure via the ```accept``` method.

There are two parts to this challenge.


__Part 1: Implement Three Different Visitors__

Each class has three methods you must write implementations for:

1. ```getResult()```: Return an integer denoting the ___result___, which is different for each class:

    - The sumInLeavesVisitor implementation must return the sum of the values in teh tree's leaves only.
    
    - The ProductRedNodesVisitor implementation must return the product of values stored in all red nodes, including leaves, computed module __10<sup>9</sup> + 7. Note that the product of zero values is equal to __1__.
    
    - The FancyVisitor implementation must return the absolute diffrerence between the sum of values stored in the tree's non-leaf nodes at even depth and the sum of values stored in the tree's green leaf nodes. Recall that zero is an [even number]().
    
2. ```visitNode()```: Implement the logic responsible for visiting the tree's non-leaf nodes such that the getResult method returns the correct ___result___ for the implementing class' visitor.

3. ```visitLeaf()```: Implement the logic responsible for visiting the tree's leaf nodes such that the getResult method returns the correct ___result___ for the implementing class' visitor.

__Part II: Read and Build the Tree__

Read the ___n___-node tree, where each node is numbered from __1__ to ___n___. The tree is given as a list of node values ($x_{1},x_{2},...,x_{n}$), a list of node colors ($c_{1},c_{2},...,c_{n}$), and a list of edges. Construct this tree as an instance of the Tree class. The tree is always rooted at node numebr __1__.

Your implementations of the three visitor classes will be tested on the tree you built from the given input.

__Input Format__

The first line contains a single integer, ___n___, donting the number of nodes in the tree. 

The second line contains ___n___ space-separated integers describing the respective values of $x_{1},x_{2},...,x_{n}$.

The third line contains ___n___ space-separated binary integers describing the respective values of $c_{1},c_{2},...,c_{n}$. Each $c_{i}$ denotes the color of the $i^th$ node, where $0$ denotes red and $1$ denotes green.

Each of the $n - 1$ subsequent lines contains two space-separated integers, $u_{i}$ and $v_{i}$, describing an edge between nodes $u_{i}$ and $v_{i}$.

__Constraints__

- $2 \le n \le 10^5$

- $1 \le x_{i} \le 10^3$

- $c_{i} \in {0,1}$

- $1 \le v_{i},u_{i} \le n$

- It is guaranteed that the tree is rooted at node $1$.

__Output Format__

Do not print anything to stdout, as this is handled by locked stub in the editor. The three ```getResult()``` methods provided for you must return an integer denoting the ___result___ for the class' visitor (defined above). Note that the value returns by ProductRedNodeVisitor's getResult method must be computed modulo $10^9 + 7$

__Sample Input__

```
5
4 7 2 5 12
0 1 0 0 1
1 2
1 3
3 4
3 5
```

__Sample Output__

```
24
40
15
```

__Explanation__

![HackerrankTreeDiagram](1.png)

Locked stub code in the editor tests your three class implementations as follows:

1. Creates a SumInLeavesVisitor object whose getResult method returns the sum of the leaves in the tree, which is $7 + 5 + 12 = 24$. The locked stub code prints the returned value on a new line.

2. Creates a ProductOfRedNotesVisitor object whose getResult method returns the product of the red nodes, which is $4 * 2 * 5 = 40$. The locked stub code prints the returned value on a new line.

3. Creates a FancyVisitor object whose getResult method returns the absolute difference between the sum of the values of non-leaf nodes at even depth and the sum of the values of green leaf nodes, which is $|4 - (7 + 12)| = 15$. The locked stub code prints the returned value on a new line.

---

<details><summary>Solution</summary>
    
```java

```
</details>